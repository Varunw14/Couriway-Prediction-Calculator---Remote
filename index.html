<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Couriway Prediction Calculator</title>
<style>

/* Prevent overlap between Date and # of Runs in Chart 2 */
#chart-2 table.runs-table{
  table-layout: fixed; /* enforce column widths */
  width: 100%;
}
#chart-2 table.runs-table th:nth-child(1),
#chart-2 table.runs-table td:nth-child(1){
  /* Date column */
  white-space: nowrap;   /* keep on one line */
  overflow: visible;     /* allow measuring true width */
}
#chart-2 table.runs-table th:nth-child(2),
#chart-2 table.runs-table td:nth-child(2){
  /* # of Runs column */
  text-align: center;
  white-space: nowrap;
  overflow: visible;
}

    :root {
      --bg: #2e1d4d;
      --panel: #3b2966;
      --panel-elev: #483070;
      --text: #e5e7eb;
      --muted: #c4b3de;
      --accent: #7a4cd9;
      --accent-hover: #9d6af5;
      --border: #5a3c87;
      --error: #fca5a5;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --tab-bg: #3b2966;
      --tab-active-bg: #483070;
      --tab-hover: #4b3375;
      --focus: #bca3ff;
    }
    * { box-sizing: border-box; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 2rem;
      background: radial-gradient(1200px 800px at 20% -10%, #483070 0%, #2e1d4d 100%);
      color: var(--text);
    }
    .page-title {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.2px;
      margin-bottom: 1rem;
      text-align: center;
      color: #fff;
    }

    /* Tabs */
    .tab-panel {
      margin-top: 0.9rem;
    }

    .controls, .card {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-elev) 100%);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 1.25rem;
      max-width: 1200px;
      margin: 0 auto 1.25rem auto;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 0.9rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .controls label { font-weight: 600; color: var(--text); }
    .controls input[type="number"] {
      width: 170px;
      padding: 0.5rem 0.7rem;
      border: 1px solid var(--border);
      background: #3b2966;
      color: var(--text);
      border-radius: 10px;
      font-size: 0.95rem;
      outline: none;
    }
    .controls input::placeholder { color: #b59ed6; }
    .controls button {
      padding: 0.55rem 1rem;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-hover) 100%);
      color: #fff;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.15s ease;
    }
    .controls button:hover { filter: brightness(1.08); }
    .controls button:active { transform: translateY(1px); }
    .controls button:disabled { opacity: 0.5; cursor: not-allowed; }
    h1, h2, h3 { margin: 0 0 0.25rem 0; }
    h2 { font-size: 1.3rem; }
    .status { font-size: 0.95rem; margin-bottom: 0.75rem; color: var(--muted); }
    .metric { font-weight: 700; margin-bottom: 0.45rem; color: var(--text); }
    .spacer { height: 12px; }
    .error { color: var(--error); white-space: pre-wrap; }
    .toggle-btn {
      display: inline-block;
      margin: 0.5rem 0;
      padding: 0.45rem 0.9rem;
      font-size: 0.9rem;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      background: #3b2966;
      color: var(--text);
      cursor: pointer;
    }
    .toggle-btn:hover { background: #4b3375; }
    .table-container { margin-top: 1rem; }
    .collapsed { display: none; }
    .hidden { display: none; }

    /* Google Table purple theming */
    .google-visualization-table-table,
    .google-visualization-table-table * {
      color: var(--text) !important;
      background: transparent !important;
      border-color: var(--border) !important;
    }
    .google-visualization-table-tr-even { background: rgba(255,255,255,0.06) !important; }
    .google-visualization-table-tr-odd { background: rgba(255,255,255,0.03) !important; }
    .google-visualization-table-th { font-weight: 700 !important; }
    .google-visualization-table-div-page { color: var(--muted) !important; }
  
    .tabs {
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
      margin-bottom:22px;
    }
    .tab {
      padding:10px 16px;
      border:1px solid var(--border);
      border-bottom:2px solid transparent;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      color:var(--text);
      border-radius: 12px;
      cursor:pointer;
      transition: all .2s ease;
      box-shadow: var(--shadow);
      user-select:none;
    }
    .tab[aria-selected="true"] {
      background: linear-gradient(180deg, rgba(187,167,255,0.18), rgba(187,167,255,0.06));
      border-color: var(--accent);
      border-bottom-color: var(--accent);
      transform: translateY(-1px);
    }

  
    /* Stronghold grid layout */
    .row{display:grid; gap:14px}
    @media (min-width:900px){ .row{ grid-template-columns: 1.2fr 1fr; } }
    .grid-3{display:grid; gap:12px}
    @media (min-width:700px){ .grid-3{ grid-template-columns: repeat(3,1fr);} }

    label{ display:block; font-weight:600; margin-bottom:6px; }
    input[type="number"], input[type="text"]{
      width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      background: rgba(255,255,255,0.05); color:var(--text); outline:none;
    }

    /* Stronghold "Calculate" button style (same as Load Data) */
    .calc-btn {
      padding: 0.55rem 1rem;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-hover) 100%);
      color: #fff;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.15s ease;
    }
    .calc-btn:hover { filter: brightness(1.08); }
    .calc-btn:active { transform: translateY(1px); }
    .calc-btn:disabled { opacity: 0.5; cursor: not-allowed; }

  
    /* 100K Statistics: responsive charts grid */
    .charts-grid{
      display:grid;
      gap:14px;
      grid-template-columns: repeat(1, minmax(0, 1fr));
    }
    @media (min-width:560px){ .charts-grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (min-width:900px){ .charts-grid{ grid-template-columns: repeat(3, minmax(0, 1fr)); } }
    @media (min-width:1200px){ .charts-grid{ grid-template-columns: repeat(3, minmax(0, 1fr)); } }
    @media (min-width:1500px){ .charts-grid{ grid-template-columns: repeat(3, minmax(0, 1fr)); } }

    .chart-card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-elev) 100%);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 0.75rem;
      min-height: 220px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }
    .chart-card .chart-slot{
      width:100%;
      height:100%;
    }
    .chart-placeholder{
      opacity:0.65;
      font-size:0.95rem;
      color:var(--muted);
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }

    
    .runs-table td:last-child {
      text-align: right;
      color: var(--text);
    }


    


    


    


    /* Auto-fit: base styles; JS will set exact font-size per cell */
    .runs-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .runs-table td {
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
      color: var(--text);
      white-space: nowrap;      /* keep one line */
      overflow: visible;        /* allow full text (we'll shrink to fit) */
      line-height: 1.1;
    }
    .runs-table td:first-child {
      font-weight: 600;
      color: var(--muted);
    }
    .runs-title {
      text-align:center;
      margin: 0 0 0.5rem 0;
      font-weight: 700;
      color: var(--text);
      line-height: 1.1;
      white-space: nowrap;
    }


    


    


    /* Ensure chart titles have no preset font-size; JS will maximize them */
    .chart-slot h3 {
      text-align: center;
      margin: 0.5rem 0;
      font-weight: 700;
      color: var(--text);
      line-height: 1.15;
      white-space: nowrap; /* single line */
    }

</style>
<script src="https://www.gstatic.com/charts/loader.js">
    // ---- Stronghold calc ----
    
    // ---- Stronghold calc (compat) ----
    function strongholdCalc() {
      var xEl = document.getElementById('ow-x');
      var zEl = document.getElementById('ow-z');
      var a1El = document.getElementById('angle-1');
      var a2El = document.getElementById('angle-2');
      var scEl = document.getElementById('sub-chunk');

      var errEl = document.getElementById('stronghold-error');
      var outCard = document.getElementById('stronghold-output-card');
      var coordsEl = document.getElementById('stronghold-coords');

      function showErr(msg) {
        if (errEl) { errEl.textContent = msg; errEl.style.display = 'block'; }
        if (outCard) outCard.classList.remove('hidden');
        if (coordsEl) coordsEl.textContent = 'Stronghold Nether Coordinates: —, —';
      }
      function hideErr() {
        if (errEl) { errEl.textContent = ''; errEl.style.display = 'none'; }
      }

      var x = parseFloat(xEl ? xEl.value : '');
      var z = parseFloat(zEl ? zEl.value : '');
      var a1 = parseFloat(a1El ? a1El.value : '');
      var a2 = parseFloat(a2El ? a2El.value : '');
      var sc = parseFloat(scEl ? scEl.value : '');

      if (!(isFinite(x) && isFinite(z) && isFinite(a1) && isFinite(a2) && isFinite(sc))) {
        showErr('Please enter valid numbers for all fields.');
        return;
      }
      if (sc < 0 || sc > 8) {
        showErr('Sub-Chunk must be between 0 and 8.');
        return;
      }

      var diff = Math.abs(a1 - a2);
      var rad = diff * Math.PI / 180;
      var t = Math.tan(rad);
      if (!isFinite(t) || Math.abs(t) < 1e-12) {
        showErr('Angles are too similar; tan(Δ) is near zero. Please adjust inputs.');
        return;
      }
      var K = 2 / t; // 2 / tan(|a1 - a2|)
      var scScale = (sc / 8.0);
      var xOvernet = x / 8.0;
      var zOvernet = z / 8.0;

      var x1 = null, z1 = null;

      function inRange(a, lo, hi) { return a >= lo && a <= hi; }

      if (inRange(a1, -90, -45.1)) {
        x1 = ( K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
      } else if (inRange(a1, -135, -90.1)) {
        x1 = ( K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
      } else if (inRange(a1, -180, -135.1)) {
        z1 = ( -K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
      } else if (inRange(a1, 135, 180)) {
        z1 = ( -K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
      } else if (inRange(a1, 90, 134.9)) {
        x1 = ( -K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
      } else if (inRange(a1, 45, 89.9)) {
        x1 = ( -K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
      } else if (inRange(a1, 0, 44.9)) {
        z1 = ( K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
      } else if (inRange(a1, -45, -0.1)) {
        z1 = ( K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
      } else {
        showErr('1st Angle of Throw is outside all specified ranges.');
        return;
      }

      hideErr();
      if (outCard) outCard.classList.remove('hidden');

      var xf = isFinite(x1) ? Math.round(x1) : '—';
      var zf = isFinite(z1) ? Math.round(z1) : '—';
      if (coordsEl) coordsEl.textContent = 'Stronghold Nether Coordinates: ' + xf + ', ' + zf;
      var owEl = document.getElementById('stronghold-overworld');
      var x2 = (isFinite(x1) ? Math.round(x1) * 8 : '—');
      var z2 = (isFinite(z1) ? Math.round(z1) * 8 : '—');
      if (owEl) owEl.textContent = 'Stronghold Overworld Coordinates: ' + x2 + ', ' + z2;      // Optional: scroll into view
      if (outCard && outCard.scrollIntoView) { outCard.scrollIntoView({behavior:'smooth', block:'nearest'}); }
    }

      function hideErr() {
        if (errEl) { errEl.textContent = ''; errEl.style.display = 'none'; }
      }

      const x = parseFloat(xStr);
      const z = parseFloat(zStr);
      const a1 = parseFloat(a1Str);
      const a2 = parseFloat(a2Str);
      const sc = parseFloat(scStr);

      if (![x,z,a1,a2,sc].every(v => Number.isFinite(v))) {
        showErr('Please enter valid numbers for all fields.');
        return;
      }
      if (sc < 0 || sc > 8) {
        showErr('Sub-Chunk must be between 0 and 8.');
        return;
      }

      const diff = Math.abs(a1 - a2);
      const rad = diff * Math.PI / 180;
      const t = Math.tan(rad);
      if (!Number.isFinite(t) || Math.abs(t) < 1e-12) {
        showErr('Angles are too similar; tan(Δ) is near zero. Please adjust inputs.');
        return;
      }
      const K = 8 / t; // 8 / tan(|a1 - a2|)
      const scScale = (sc / 8.0);
      const xOvernet = x / 8.0;
      const zOvernet = z / 8.0;

      let x1 = null, z1 = null;

      function inRange(a, lo, hi) { return a >= lo && a <= hi; }

      if (inRange(a1, -90, -45.1)) {
        x1 = ( K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
      } else if (inRange(a1, -135, -90.1)) {
        x1 = ( K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
      } else if (inRange(a1, -180, -135.1)) {
        z1 = ( -K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
      } else if (inRange(a1, 135, 180)) {
        z1 = ( -K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
      } else if (inRange(a1, 90, 134.9)) {
        x1 = ( -K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
      } else if (inRange(a1, 45, 89.9)) {
        x1 = ( -K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
      } else if (inRange(a1, 0, 44.9)) {
        z1 = ( K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
      } else if (inRange(a1, -45, -0.1)) {
        z1 = ( K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
      } else {
        showErr('1st Angle of Throw is outside all specified ranges.');
        return;
      }

      hideErr();
      if (outCard) outCard.classList.remove('hidden');

      const xf = Number.isFinite(x1) ? x1.toFixed(3) : '—';
      const zf = Number.isFinite(z1) ? z1.toFixed(3) : '—';
      if (coordsEl) coordsEl.textContent = `Stronghold Nether Coordinates: ${xf}, ${zf}`;

</script>
<script>
// ---- Tabs logic ----
    function initTabs() {
      const tablist = document.querySelector('[role="tablist"]');
      if (!tablist) return;
      const tabs = Array.from(tablist.querySelectorAll('[role="tab"]'));
      const panels = Array.from(document.querySelectorAll('[role="tabpanel"]'));

      function activateTab(tab) {
        tabs.forEach(t => t.setAttribute('aria-selected', String(t === tab)));
        panels.forEach(p => p.hidden = (p.id !== tab.getAttribute('aria-controls')));
      }

      tabs.forEach(tab => {
        tab.addEventListener('click', () => activateTab(tab));
        tab.addEventListener('keydown', (e) => {
          const idx = tabs.indexOf(tab);
          if (e.key === 'ArrowRight') { e.preventDefault(); const n = tabs[(idx+1)%tabs.length]; n.focus(); activateTab(n); }
          if (e.key === 'ArrowLeft') { e.preventDefault(); const p = tabs[(idx-1+tabs.length)%tabs.length]; p.focus(); activateTab(p); }
        });
      });

      // Activate first selected tab on load
      const selected = tabs.find(t => t.getAttribute('aria-selected') === 'true') || tabs[0];
      if (selected) activateTab(selected);
    }

    // ---- Existing app logic ----
    const SPREADSHEET_ID = "1Tyw9fwdZgsHJoHzlE-0LPSEDOduRkZwL2UUNA-_4Xo4";
    const GID_PROCESSED = "1760430564";
    const GID_SECOND = "1885267609";

    let chartsReady = false;
    let t1Ready = false;
    let t2Ready = false;

    // Storage for stitching
    let t1Rows = []; // {date, igt, run}
    let t2Map = new Map(); // runNum(int) -> { predNum: number|null, predQ: string }
    let stitchedRows = []; // { igtNum:number|null, predNum:number|null, predQ:string }
    let rowLimitUsed = 50;

    // Cached numeric values for safe minimums
    let timeYesVal = null;
    let timeNoVal = null;
    let predYesVal = null;
    let predNoVal = null;

    google.charts.load("current", { packages: ["table"] });
    google.charts.setOnLoadCallback(() => {
      chartsReady = true;
      const btn = document.getElementById("load-btn");
      if (btn) btn.disabled = false;
      const hint = document.getElementById("hint");
      if (hint) hint.textContent = "Choose a Number of Runs as a sample size and the Current Prediction, then click Load Data.";
    });

    window.addEventListener('DOMContentLoaded', initTabs);

    function buildQuery(limit) {
      const n = Number(limit);
      const safe = (Number.isFinite(n) && n > 0) ? Math.floor(n) : 50;
      rowLimitUsed = safe;
      return `select * limit ${safe}`;
    }

    function clearOutputs() {
      t1Ready = false; t2Ready = false;
      t1Rows = [];
      t2Map.clear();
      stitchedRows = [];

      timeYesVal = null;
      timeNoVal  = null;
      predYesVal = null;
      predNoVal  = null;

      setText("status1", "—");
      setText("status2", "—");
      setText("statusStitched", "—");
      setText("propBelow", "—");
      setText("timeYes", "—");
      setText("timeNo", "—");
      setText("predSuccess", "—");
      setText("predBasedYes", "—");
      setText("predBasedNo", "—");
      setText("safeYes", "—");
      setText("safeNo", "—");
      hideAndClear("error1");
      hideAndClear("error2");
      setHTML("table1", "");
      setHTML("stitched-table", "");
      document.getElementById("stitched-card").classList.add("hidden");

      // Ensure second card initially visible (but will hide after stitch)
      document.getElementById("card2").classList.remove("hidden");

      // Reset toggles/collapsed
      setCollapsed('stitched', true);
      setText("toggle-btn-stitched", "Show Results Table");
    }

    function loadAll() {
      if (!chartsReady) return;
      const limitInput = document.getElementById("row-limit");
      const query = buildQuery(limitInput.value);
      clearOutputs();
      loadViaJSONP(GID_PROCESSED, "handleProcessed", query);
      loadViaJSONP(GID_SECOND, "handleSecond", query);
    }

    function setText(id, text) {
      const el = document.getElementById(id);
      if (el) el.textContent = text;
    }
    function setHTML(id, html) {
      const el = document.getElementById(id);
      if (el) el.innerHTML = html;
    }
    function hideAndClear(id) {
      const el = document.getElementById(id);
      if (el) { el.style.display = "none"; el.textContent = ""; }
    }
    function setError(id, text) {
      const el = document.getElementById(id);
      if (el) { el.textContent = text; el.style.display = "block"; }
    }

    function loadViaJSONP(gid, handlerName, query) {
      const base = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq`;
      const params = new URLSearchParams({
        gid: gid,
        tq: query,
        tqx: `out:json;responseHandler:${handlerName}`
      });
      const url = `${base}?${params.toString()}`;
      const script = document.createElement("script");
      script.src = url;
      script.onerror = () => {
        if (gid === GID_PROCESSED) {
          setText("status1", "Failed to load data.");
          setError("error1", "Network or permissions error when loading the Google Sheets JSONP endpoint.");
        } else {
          setText("status2", "Failed to load data.");
          setError("error2", "Network or permissions error when loading the Google Sheets JSONP endpoint.");
        }
      };
      document.head.appendChild(script);
    }

    // === TABLE 1 handler (processed) ===
    function handleProcessed(response) {
      if (response.status !== "ok") {
        setText("status1", "Failed to load data.");
        const err = (response && response.errors && response.errors[0]) || {};
        setError("error1", "Google Sheets returned an error. " + (err.message || "Unknown error"));
        return;
      }
      try {
        const dataTable = new google.visualization.DataTable(response.table);

        t1Rows = [];
        for (let r = 1; r < dataTable.getNumberOfRows(); r++) { // skip first data row
          const val1 = dataTable.getValue(r, 0);   // col 1
          const val87 = dataTable.getValue(r, 86); // col 87
          const val93 = dataTable.getValue(r, 92); // col 93

          const out1 = (val1 == null) ? "" : String(val1);

          let out87 = (val87 == null) ? "" : String(val87);
          const parts = out87.split(":");
          if (parts.length === 3) out87 = parts[1];

          let runNum = null;
          if (typeof val93 === "string") {
            const num = parseInt(val93.replace(/,/g, ""), 10);
            if (!isNaN(num)) { runNum = num; }
          } else if (typeof val93 === "number") {
            runNum = val93;
          }

          if (runNum !== null && Number.isFinite(runNum)) {
            t1Rows.push({ date: out1, igt: out87, run: runNum });
          }
        }

        setText("status1", `Processed ${t1Rows.length} rows (limit ${rowLimitUsed}).`);
        t1Ready = true;
        maybeStitch();
      } catch (e) {
        setText("status1", "Failed to process table.");
        setError("error1", "Parsing/rendering error: " + (e.message || e));
      }
    }

    // === TABLE 2 handler (used for stitching only) ===
    function handleSecond(response) {
      if (response.status !== "ok") {
        setText("status2", "Failed to load data.");
        const err = (response && response.errors && response.errors[0]) || {};
        setError("error2", "Google Sheets returned an error. " + (err.message || e));
        return;
      }
      try {
        const dataTable = new google.visualization.DataTable(response.table);

        // Find columns by label: "run num", "Pred #", "Pred?"
        let runIdx = -1, predNumIdx = -1, predQIdx = -1;
        for (let c = 0; c < dataTable.getNumberOfColumns(); c++) {
          const raw = dataTable.getColumnLabel(c) || "";
          const label = raw.trim().toLowerCase();
          if (label === "run num") runIdx = c;
          if (raw.trim() === "Pred #") predNumIdx = c; // exact match
          if (raw.trim() === "Pred?") predQIdx = c;
        }

        if (runIdx === -1) {
          setText("status2", "Loaded, but couldn't find a 'run num' column to stitch on.");
        } else {
          t2Map.clear();
          for (let r = 1; r < dataTable.getNumberOfRows(); r++) { // skip first data row
            const keyVal = dataTable.getValue(r, runIdx);
            let keyInt = null;
            if (typeof keyVal === "string") {
              const num = parseInt(keyVal.replace(/,/g, ""), 10);
              if (!isNaN(num)) keyInt = num;
            } else if (typeof keyVal === "number") {
              keyInt = keyVal;
            }
            if (keyInt === null) continue;

            // Extract Pred # and Pred?
            let predNum = null;
            if (predNumIdx !== -1) {
              const pv = dataTable.getValue(r, predNumIdx);
              if (typeof pv === "string") {
                const num = parseInt(pv.replace(/,/g, ""), 10);
                predNum = isNaN(num) ? null : num;
              } else if (typeof pv === "number") {
                predNum = pv;
              } else {
                predNum = null;
              }
            }

            const predQ = (predQIdx !== -1)
              ? (dataTable.getValue(r, predQIdx) == null ? "" : String(dataTable.getValue(r, predQIdx)))
              : "";

            t2Map.set(keyInt, { predNum, predQ });
          }
          setText("status2", `Loaded ${t2Map.size} stitchable rows (limit ${rowLimitUsed}).`);
        }

        t2Ready = true;
        maybeStitch();
      } catch (e) {
        setText("status2", "Failed to parse second table.");
        setError("error2", "Parsing/rendering error: " + (e.message || e));
      }
    }

    // Stitch when both are ready
    function maybeStitch() {
      if (!t1Ready || !t2Ready) return;

      // Build stitched DataTable: first table's 3 cols + "Pred #" + "Pred?"
      const stitched = new google.visualization.DataTable();
      stitched.addColumn("string", "Date Played (EST)");
      stitched.addColumn("string", "IGT");
      stitched.addColumn("number", "run number");
      stitched.addColumn("number", "Pred #");
      stitched.addColumn("string", "Pred?");

      let joinedCount = 0;
      const igtValues = []; // numeric IGTs for proportion calc
      stitchedRows = [];

      t1Rows.forEach(({ date, igt, run }) => {
        const match = t2Map.get(run);
        if (match) {
          const { predNum, predQ } = match;
          stitched.addRow([date, igt, run, predNum, predQ]);
          joinedCount++;

          const igtNum = (igt == null) ? NaN : parseFloat(String(igt).trim());
          if (!Number.isNaN(igtNum)) igtValues.push(igtNum);

          stitchedRows.push({
            igtNum: Number.isNaN(igtNum) ? null : igtNum,
            predNum: (typeof predNum === "number" && Number.isFinite(predNum)) ? predNum : null,
            predQ: predQ == null ? "" : String(predQ)
          });
        }
      });

      // Draw stitched table
      const table = new google.visualization.Table(document.getElementById("stitched-table"));
      table.draw(stitched, { showRowNumber: true, width: "100%", allowHtml: true });

      // Show card, keep table collapsed by default
      document.getElementById("stitched-card").classList.remove("hidden");
      setCollapsed('stitched', true);
      setText("toggle-btn-stitched", "Show Results Table");
      document.getElementById("card2").classList.add("hidden");

      setText("statusStitched", `Stitched ${joinedCount} rows (limit ${rowLimitUsed}) -> ${rowLimitUsed-joinedCount-1} current version runs in sample size`);

      // Compute metrics
      computeProportionBelow(igtValues);
      computePredSuccess(stitchedRows);
    }

    function computeProportionBelow(igtValues) {
      const predInput = document.getElementById("current-pred");
      const raw = predInput ? predInput.value : "";
      const threshold = parseFloat(String(raw).trim());
      if (!Number.isFinite(threshold)) {
        setText("propBelow", "Enter a numeric Current Prediction to compute proportion.");
        setText("timeYes", "—");
        setText("timeNo", "—");
        timeYesVal = null; timeNoVal = null;
        computeSafeMinimums();
        return;
      }
      const valid = igtValues.filter(v => Number.isFinite(v));
      if (valid.length === 0) {
        setText("propBelow", "No valid IGT values to compute proportion.");
        setText("timeYes", "—");
        setText("timeNo", "—");
        timeYesVal = null; timeNoVal = null;
        computeSafeMinimums();
        return;
      }
      const belowCount = valid.reduce((acc, v) => acc + (v < threshold ? 1 : 0), 0);
      const proportion = belowCount / valid.length;
      setText("propBelow", `Proportion of IGT < Current Prediction: ${proportion.toFixed(4)} (${belowCount}/${valid.length})`);

      // Time-based Yes/No
      let tYes = null, tNo = null;
      if (proportion > 0) {
        tYes = 1 / proportion;
        setText("timeYes", `Time-based Yes: ${tYes.toFixed(4)}`);
      } else {
        setText("timeYes", "Time-based Yes: ∞ (proportion = 0)");
        tYes = Infinity;
      }
      if (proportion < 1) {
        tNo = 1 / (1 - proportion);
        setText("timeNo", `Time-based No: ${tNo.toFixed(4)}`);
      } else {
        setText("timeNo", "Time-based No: ∞ (proportion = 1)");
        tNo = Infinity;
      }
      timeYesVal = tYes;
      timeNoVal  = tNo;
      computeSafeMinimums();
    }

    function computePredSuccess(rows) {
      const predInput = document.getElementById("current-pred");
      const raw = predInput ? predInput.value : "";
      const target = parseFloat(String(raw).trim());
      if (!Number.isFinite(target)) {
        setText("predSuccess", "Enter a numeric Current Prediction to compute proportion of pred success.");
        setText("predBasedYes", "—");
        setText("predBasedNo", "—");
        predYesVal = null; predNoVal = null;
        computeSafeMinimums();
        return;
      }
      const matched = rows.filter(r => r.predNum !== null && r.predNum === target);
      if (matched.length === 0) {
        setText("predSuccess", "Proportion of Pred Success: 0.0000 (0/0 matched to Current Prediction)");
        setText("predBasedYes", "Pred-based Yes: ∞ (proportion = 0)");
        setText("predBasedNo", "Pred-based No: 1.0000");
        predYesVal = Infinity;
        predNoVal = 1.0;
        computeSafeMinimums();
        return;
      }
      const yCount = matched.reduce((acc, r) => acc + ((r.predQ || '').trim().toUpperCase() === 'Y' ? 1 : 0), 0);
      const proportion = yCount / matched.length;
      setText("predSuccess", `Proportion of Pred Success: ${proportion.toFixed(4)} (${yCount}/${matched.length} with Pred? = Y)`);

      // Pred-based Yes/No
      let pYes = null, pNo = null;
      if (proportion > 0) {
        pYes = 1 / proportion;
        setText("predBasedYes", `Pred-based Yes: ${pYes.toFixed(4)}`);
      } else {
        setText("predBasedYes", "Pred-based Yes: ∞ (proportion = 0)");
        pYes = Infinity;
      }
      if (proportion < 1) {
        pNo = 1 / (1 - proportion);
        setText("predBasedNo", `Pred-based No: ${pNo.toFixed(4)}`);
      } else {
        setText("predBasedNo", "Pred-based No: ∞ (proportion = 1)");
        pNo = Infinity;
      }
      predYesVal = pYes;
      predNoVal  = pNo;
      computeSafeMinimums();
    }

    function computeSafeMinimums() {
      const safeYesEl = document.getElementById("safeYes");
      const safeNoEl = document.getElementById("safeNo");
      if (!safeYesEl || !safeNoEl) return;

      function maxPretty(a, b) {
        if (a === Infinity || b === Infinity) return "∞";
        if (a == null && b == null) return "—";
        if (a == null) return (typeof b === "number") ? b.toFixed(4) : "—";
        if (b == null) return (typeof a === "number") ? a.toFixed(4) : "—";
        return Math.max(a, b).toFixed(4);
      }

      const safeYesText = maxPretty(predYesVal, timeYesVal);
      const safeNoText  = maxPretty(predNoVal,  timeNoVal);

      safeYesEl.textContent = `Safe Minimum Yes: ${safeYesText}`;
      safeNoEl.textContent  = `Safe Minimum No: ${safeNoText}`;
    }

    // Toggle helpers
    function setCollapsed(which, collapsed) {
      const containerId = which === 'stitched' ? "stitched-container" : "table-container2";
      const container = document.getElementById(containerId);
      if (!container) return;
      if (collapsed) container.classList.add("collapsed");
      else container.classList.remove("collapsed");
    }
    function toggleTable(which) {
      const btnId = which === 'stitched' ? "toggle-btn-stitched" : "toggle-btn2";
      const containerId = which === 'stitched' ? "stitched-container" : "table-container2";
      const container = document.getElementById(containerId);
      const btn = document.getElementById(btnId);
      if (container.classList.contains("collapsed")) {
        container.classList.remove("collapsed");
        btn.textContent = which === 'stitched' ? "Hide Results Table" : "Hide Table";
      } else {
        container.classList.add("collapsed");
        btn.textContent = which === 'stitched' ? "Show Results Table" : "Show Table";
      }
    }
  
    // ---- Stronghold calc (global) ----
    function strongholdCalc() {
      var xEl = document.getElementById('ow-x');
      var zEl = document.getElementById('ow-z');
      var a1El = document.getElementById('angle-1');
      var a2El = document.getElementById('angle-2');
      var scEl = document.getElementById('sub-chunk');

      var errEl = document.getElementById('stronghold-error');
      var outCard = document.getElementById('stronghold-output-card');
      var coordsEl = document.getElementById('stronghold-coords');

      function showErr(msg) {
        if (errEl) { errEl.textContent = msg; errEl.style.display = 'block'; }
        if (outCard) outCard.classList.remove('hidden');
        if (coordsEl) coordsEl.textContent = 'Stronghold Nether Coordinates: —, —';
      }
      function hideErr() {
        if (errEl) { errEl.textContent = ''; errEl.style.display = 'none'; }
      }

      var x = parseFloat(xEl ? xEl.value : '');
      var z = parseFloat(zEl ? zEl.value : '');
      var a1 = parseFloat(a1El ? a1El.value : '');
      var a2 = parseFloat(a2El ? a2El.value : '');
      var sc = parseFloat(scEl ? scEl.value : '');

      if (!(isFinite(x) && isFinite(z) && isFinite(a1) && isFinite(a2) && isFinite(sc))) {
        showErr('Please enter valid numbers for all fields.');
        return;
      }
      if (sc < 0 || sc > 8) {
        showErr('Sub-Chunk must be between 0 and 8.');
        return;
      }

      var diff = Math.abs(a1 - a2);
      var rad = diff * Math.PI / 180;
      var t = Math.tan(rad);
      if (!isFinite(t) || Math.abs(t) < 1e-12) {
        showErr('Angles are too similar; tan(Δ) is near zero. Please adjust inputs.');
        return;
      }
      var K = 2 / t; // 2 / tan(|a1 - a2|)
      var scScale = (sc / 8.0);
      var xOvernet = x / 8.0;
      var zOvernet = z / 8.0;

      var x1 = null, z1 = null;

      function inRange(a, lo, hi) { return a >= lo && a <= hi; }

      if (inRange(a1, -90, -45.1)) {
        x1 = ( K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
      } else if (inRange(a1, -135, -90.1)) {
        x1 = ( K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
      } else if (inRange(a1, -180, -135.1)) {
        z1 = ( -K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
      } else if (inRange(a1, 135, 180)) {
        z1 = ( -K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
      } else if (inRange(a1, 90, 134.9)) {
        x1 = ( -K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
      } else if (inRange(a1, 45, 89.9)) {
        x1 = ( -K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
      } else if (inRange(a1, 0, 44.9)) {
        z1 = ( K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
      } else if (inRange(a1, -45, -0.1)) {
        z1 = ( K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
      } else {
        showErr('1st Angle of Throw is outside all specified ranges.');
        return;
      }

      hideErr();
      if (outCard) outCard.classList.remove('hidden');

      var xf = isFinite(x1) ? Math.round(x1) : '—';
      var zf = isFinite(z1) ? Math.round(z1) : '—';
      if (coordsEl) coordsEl.textContent = 'Stronghold Nether Coordinates: ' + xf + ', ' + zf;
      var owEl = document.getElementById('stronghold-overworld');
      var x2 = (isFinite(x1) ? Math.round(x1) * 8 : '—');
      var z2 = (isFinite(z1) ? Math.round(z1) * 8 : '—');
      if (owEl) owEl.textContent = 'Stronghold Overworld Coordinates: ' + x2 + ', ' + z2;      if (outCard && outCard.scrollIntoView) { outCard.scrollIntoView({behavior:'smooth', block:'nearest'}); }
    }


    // ---- Stronghold: toggle working ----
    function toggleStrongholdWorking() {
      var c = document.getElementById('stronghold-working-container');
      var btn = document.getElementById('stronghold-working-toggle');
      if (!c || !btn) return;
      var collapsed = c.classList.contains('collapsed');
      if (collapsed) {
        c.classList.remove('collapsed');
        btn.textContent = 'Hide Working';
      } else {
        c.classList.add('collapsed');
        btn.textContent = 'Show Working';
      }
    }

    // ---- Stronghold: copy nether coords ----
    function copyNetherCoords() {
      var el = document.getElementById('stronghold-coords');
      if (!el) return;
      var txt = el.textContent || '';
      // Expect format: "Stronghold Nether Coordinates: X, Z"
      var idx = txt.indexOf(':');
      var payload = (idx >= 0) ? txt.slice(idx+1).trim() : txt.trim();
      function done(ok) {
        var btn = document.getElementById('copy-nether-btn');
        if (!btn) return;
        var old = btn.textContent;
        btn.textContent = ok ? 'Copied!' : 'Copy failed';
        setTimeout(function(){ btn.textContent = old; }, 1400);
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(payload).then(function(){ done(true); }, function(){ done(false); });
      } else {
        // Fallback
        var ta = document.createElement('textarea');
        ta.value = payload;
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); done(true); } catch(e){ done(false); }
        document.body.removeChild(ta);
      }
    }

    // ---- Stronghold calc (with working; K = 2/t; whole-number output) ----
    function strongholdCalc() {
      var xEl = document.getElementById('ow-x');
      var zEl = document.getElementById('ow-z');
      var a1El = document.getElementById('angle-1');
      var a2El = document.getElementById('angle-2');
      var scEl = document.getElementById('sub-chunk');

      var errEl = document.getElementById('stronghold-error');
      var outCard = document.getElementById('stronghold-output-card');
      var coordsEl = document.getElementById('stronghold-coords');
      var workEl = document.getElementById('stronghold-working');

      function showErr(msg) {
        if (errEl) { errEl.textContent = msg; errEl.style.display = 'block'; }
        if (outCard) outCard.classList.remove('hidden');
        if (coordsEl) coordsEl.textContent = 'Stronghold Nether Coordinates: —, —';
        if (workEl) workEl.textContent = '';
      }
      function hideErr() {
        if (errEl) { errEl.textContent = ''; errEl.style.display = 'none'; }
      }
      function fmt(n, d) { return (isFinite(n) ? n.toFixed(d) : String(n)); }

      var x = parseFloat(xEl ? xEl.value : '');
      var z = parseFloat(zEl ? zEl.value : '');
      var a1 = parseFloat(a1El ? a1El.value : '');
      var a2 = parseFloat(a2El ? a2El.value : '');
      var sc = parseFloat(scEl ? scEl.value : '');

      if (!(isFinite(x) && isFinite(z) && isFinite(a1) && isFinite(a2) && isFinite(sc))) {
        showErr('Please enter valid numbers for all fields.');
        return;
      }
      if (sc < 0 || sc > 8) {
        showErr('Sub-Chunk must be between 0 and 8.');
        return;
      }

      var steps = [];
      steps.push('Inputs:');
      steps.push('  OW X Coordinate = ' + x);
      steps.push('  OW Z Coordinate = ' + z);
      steps.push('  1st Angle of Throw = ' + a1);
      steps.push('  2nd Angle of Throw = ' + a2);
      steps.push('  Sub-Chunk = ' + sc);

      var diff = Math.abs(a1 - a2);
      var rad = diff * Math.PI / 180;
      var t = Math.tan(rad);
      if (!isFinite(t) || Math.abs(t) < 1e-12) {
        showErr('Angles are too similar; tan(Δ) is near zero. Please adjust inputs.');
        return;
      }
      var K = 2 / t; // 2 / tan(|a1 - a2|) per user
      var scScale = (sc / 8.0);
      var xOvernet = x / 8.0;
      var zOvernet = z / 8.0;

      steps.push('');
      steps.push('Δ = |a1 - a2| = ' + fmt(diff, 4) + '°');
      steps.push('radians = Δ × π / 180 = ' + fmt(rad, 6));
      steps.push('tan(Δ) = ' + fmt(t, 6));
      steps.push('K = 2 / tan(Δ) = ' + fmt(K, 6));
      steps.push('Sub-Chunk scale = sc / 8 = ' + fmt(scScale, 6));
      steps.push('OW→Nether scale: x/8 = ' + fmt(xOvernet, 6) + ', z/8 = ' + fmt(zOvernet, 6));

      var x1 = null, z1 = null, rule = '';

      function inRange(a, lo, hi) { return a >= lo && a <= hi; }

      if (inRange(a1, -90, -45.1)) {
        rule = 'Rule: a1 in [-90, -45.1]';
        x1 = ( K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
        steps.push(''); steps.push(rule);
        steps.push('x1 = K + x/8 = ' + fmt(K, 6) + ' + ' + fmt(xOvernet, 6));
        steps.push('z1 = (K)*(sc/8) + z/8 = ' + fmt(K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(zOvernet, 6));
      } else if (inRange(a1, -135, -90.1)) {
        rule = 'Rule: a1 in [-135, -90.1]';
        x1 = ( K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
        steps.push(''); steps.push(rule);
        steps.push('x1 = K + x/8 = ' + fmt(K, 6) + ' + ' + fmt(xOvernet, 6));
        steps.push('z1 = (-K)*(sc/8) + z/8 = ' + fmt(-K, 6) + ' * ' + ' ' + fmt(scScale, 6) + ' + ' + fmt(zOvernet, 6));
      } else if (inRange(a1, -180, -135.1)) {
        rule = 'Rule: a1 in [-180, -135.1]';
        z1 = ( -K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
        steps.push(''); steps.push(rule);
        steps.push('z1 = -K + z/8 = ' + fmt(-K, 6) + ' + ' + fmt(zOvernet, 6));
        steps.push('x1 = (K)*(sc/8) + x/8 = ' + fmt(K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(xOvernet, 6));
      } else if (inRange(a1, 135, 180)) {
        rule = 'Rule: a1 in [135, 180]';
        z1 = ( -K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
        steps.push(''); steps.push(rule);
        steps.push('z1 = -K + z/8 = ' + fmt(-K, 6) + ' + ' + fmt(zOvernet, 6));
        steps.push('x1 = (-K)*(sc/8) + x/8 = ' + fmt(-K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(xOvernet, 6));
      } else if (inRange(a1, 90, 134.9)) {
        rule = 'Rule: a1 in [90, 134.9]';
        x1 = ( -K + xOvernet );
        z1 = ( (-K) * scScale + zOvernet );
        steps.push(''); steps.push(rule);
        steps.push('x1 = -K + x/8 = ' + fmt(-K, 6) + ' + ' + fmt(xOvernet, 6));
        steps.push('z1 = (-K)*(sc/8) + z/8 = ' + fmt(-K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(zOvernet, 6));
      } else if (inRange(a1, 45, 89.9)) {
        rule = 'Rule: a1 in [45, 89.9]';
        x1 = ( -K + xOvernet );
        z1 = ( ( K ) * scScale + zOvernet );
        steps.push(''); steps.push(rule);
        steps.push('x1 = -K + x/8 = ' + fmt(-K, 6) + ' + ' + fmt(xOvernet, 6));
        steps.push('z1 = (K)*(sc/8) + z/8 = ' + fmt(K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(zOvernet, 6));
      } else if (inRange(a1, 0, 44.9)) {
        rule = 'Rule: a1 in [0, 44.9]';
        z1 = ( K + zOvernet );
        x1 = ( (-K) * scScale + xOvernet );
        steps.push(''); steps.push(rule);
        steps.push('z1 = K + z/8 = ' + fmt(K, 6) + ' + ' + fmt(zOvernet, 6));
        steps.push('x1 = (-K)*(sc/8) + x/8 = ' + fmt(-K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(xOvernet, 6));
      } else if (inRange(a1, -45, -0.1)) {
        rule = 'Rule: a1 in [-45, -0.1]';
        z1 = ( K + zOvernet );
        x1 = ( ( K ) * scScale + xOvernet );
        steps.push(''); steps.push(rule);
        steps.push('z1 = K + z/8 = ' + fmt(K, 6) + ' + ' + fmt(zOvernet, 6));
        steps.push('x1 = (K)*(sc/8) + x/8 = ' + fmt(K, 6) + ' * ' + fmt(scScale, 6) + ' + ' + fmt(xOvernet, 6));
      } else {
        showErr('1st Angle of Throw is outside all specified ranges.');
        return;
      }

      hideErr();
      if (outCard) outCard.classList.remove('hidden');

      var xf = isFinite(x1) ? Math.round(x1) : '—';
      var zf = isFinite(z1) ? Math.round(z1) : '—';
      if (coordsEl) coordsEl.textContent = 'Stronghold Nether Coordinates: ' + xf + ', ' + zf;

      steps.push(''); steps.push('Result (Nether):');
      steps.push('  x1 = ' + xf);
      steps.push('  z1 = ' + zf);

      if (workEl) workEl.textContent = steps.join('\n');
      // Also update overworld line if present
      var owEl = document.getElementById('stronghold-overworld');
      var x2 = (isFinite(x1) ? Math.round(x1) * 8 : '—');
      var z2 = (isFinite(z1) ? Math.round(z1) * 8 : '—');
      if (owEl) owEl.textContent = 'Stronghold Overworld Coordinates: ' + x2 + ', ' + z2;
    }
</script>

<style>
#chart3-total {
  font-size: 0.85em;
  white-space: normal;
  word-break: break-word;
}
</style>

</head>
<body>
<div class="page-title">Couriway 100K Statistics Analysis</div>
<!-- Tabs -->
<div aria-label="Calculator sections" class="tabs" role="tablist">
<button aria-controls="panel-pred" aria-selected="true" class="tab" id="tab-pred" role="tab">Prediction Calculator</button>
<button aria-controls="panel-stronghold" aria-selected="false" class="tab" id="tab-stronghold" role="tab">Stronghold Sheetless</button>
<button aria-controls="panel-stats" aria-selected="false" class="tab" id="tab-stats" role="tab">100K Statistics</button></div>
<!-- Panels -->
<section aria-labelledby="tab-pred" class="tab-panel" id="panel-pred" role="tabpanel">
<!-- Controls -->
<div class="controls">
<label for="row-limit">Number of Runs:</label>
<input id="row-limit" min="1" step="50" type="number" value="250"/>
<label for="current-pred">Current Prediction:</label>
<input id="current-pred" placeholder="Enter prediction..." step="1" type="number"/>
<button disabled="" id="load-btn" onclick="loadAll()">Load Data</button>
<span id="hint" style="margin-left:0.25rem; color:var(--muted);">Loading chart library…</span>
</div>
<!-- Prediction Results -->
<div class="card hidden" id="stitched-card">
<h2>Prediction Results</h2>
<div aria-live="polite" class="status" id="statusStitched" role="status">—</div>
<div class="metric" id="propBelow">—</div>
<div class="metric" id="timeYes">—</div>
<div class="metric" id="timeNo">—</div>
<div class="spacer"></div>
<div class="metric" id="predSuccess">—</div>
<div class="metric" id="predBasedYes">—</div>
<div class="metric" id="predBasedNo">—</div>
<div class="spacer"></div>
<div class="metric" id="safeYes">—</div>
<div class="metric" id="safeNo">—</div>
<button class="toggle-btn" id="toggle-btn-stitched" onclick="toggleTable('stitched')">Show Results Table</button>
<div class="table-container collapsed" id="stitched-container">
<div aria-busy="true" id="stitched-table"></div>
</div>
</div>
<!-- Table 2 (hidden after stitch) -->
<div class="card" id="card2">
<h3>Prediction Results</h3>
<div class="status" id="status2">—</div>
<pre class="error" id="error2" style="display:none;"></pre>
</div>
</section>
<section aria-labelledby="tab-stronghold" class="tab-panel" hidden="" id="panel-stronghold" role="tabpanel">
<div class="card">
<h2>Ender Eye Measurements</h2>
<div class="grid-3" id="stronghold-controls">
<div>
<label for="ow-x">Overworld X Coordinate</label>
<input id="ow-x" placeholder="e.g. 1234" step="1" type="number"/>
</div>
<div>
<label for="ow-z">Overworld Z Coordinate</label>
<input id="ow-z" placeholder="e.g. -567" step="1" type="number"/>
</div>
<div>
<label for="sub-chunk">Sub-Chunk</label>
<input id="sub-chunk" max="8" min="0" placeholder="0–8" step="1" type="number"/>
</div>
<div>
<label for="angle-1">1st Angle of Throw</label>
<input id="angle-1" placeholder="e.g. 37.5" step="0.1" type="number"/>
</div>
<div>
<label for="angle-2">2nd Angle of Throw</label>
<input id="angle-2" placeholder="e.g. 41.2" step="0.1" type="number"/>
</div>
<div style="display:flex;align-items:flex-end;justify-content:flex-start">
<button class="calc-btn" id="stronghold-calc-btn" onclick="strongholdCalc();" type="button">Calculate</button>
</div>
</div>
</div>
<div class="card hidden" id="stronghold-output-card">
<h2>Stronghold Coordinates</h2>
<div style="display:flex;align-items:center;gap:0.5rem;flex-wrap:wrap;">
<div class="metric" id="stronghold-coords">Stronghold Nether Coordinates: x1, z1</div>
<button class="toggle-btn" id="copy-nether-btn" onclick="copyNetherCoords()" type="button">Copy</button>
</div>
<button class="toggle-btn" id="stronghold-working-toggle" onclick="toggleStrongholdWorking()" type="button">Show Working</button>
<div class="collapsed" id="stronghold-working-container" style="margin-top:0.5rem;"><h3 style="margin:0">Calculation Details</h3>
<pre id="stronghold-working" style="white-space:pre-wrap; margin-top:0.5rem; color: var(--muted)"></pre>
</div>
<div class="spacer"></div>
<div class="metric" id="stronghold-overworld">Stronghold Overworld Coordinates: x2, z2</div>
<pre class="error" id="stronghold-error" style="display:none;"></pre>
</div>
</section><section aria-labelledby="tab-stats" class="tab-panel" hidden="" id="panel-stats" role="tabpanel"><div class="card"><h2>100K Statistics</h2><div class="charts-grid"><div class="chart-card">
  <div class="chart-slot" id="chart-1">
    <h3 class="runs-title">Total Runs</h3>
    <table class="runs-table">
      <colgroup>
        <col style="width:60%;">
        <col style="width:40%;">
      </colgroup>
      <tbody>
        <tr><td>Runs Completed</td><td id="runs-completed">—</td></tr>
        <tr><td>Total Remaining</td><td id="total-remaining">—</td></tr>
        <tr><td>Percentage Done</td><td id="percentage-done">—</td></tr>
        <tr><td>Estimated Hours Left</td><td id="hours-remaining">—</td></tr>
        <tr><td>Estimated Finish Date</td><td id="finish-date">—</td></tr>
      </tbody>
    </table>
  </div>
</div>
<div class="chart-card">
  <div class="chart-slot" id="chart-2">
    <h3 id="chart2-title">Daily Average Rankings</h3>
<table class="runs-table">
  <colgroup>
    <col style="width:25%;">
    <col style="width:25%;">
    <col style="width:25%;">
    <col style="width:25%;">
  </colgroup>
  <thead>
    <tr>
      <th style="font-size:0.85rem;">Date</th>
      <th style="font-size:0.85rem;"># of Runs</th>
      <th style="font-size:0.85rem;">Average Time</th>
      <th style="font-size:0.85rem;">Rank</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>Day 1</td><td>—</td><td>—</td><td>—</td></tr>
    <tr><td>Day 2</td><td>—</td><td>—</td><td>—</td></tr>
    <tr><td>Day 3</td><td>—</td><td>—</td><td>—</td></tr>
    <tr><td>Day 4</td><td>—</td><td>—</td><td>—</td></tr>
    <tr><td>Day 5</td><td>—</td><td>—</td><td>—</td></tr>
    <tr><td><strong>Today</strong></td><td>—</td><td>—</td><td>—</td></tr>
  </tbody>
</table>
  </div>
</div><div class="chart-card"><div class="chart-slot" id="chart-3">
    <h3 class="runs-title">1.16.1 Stats</h3>
    <table class="runs-table">
      <colgroup>
        <col style="width:60%;">
        <col style="width:40%;">
      </colgroup>
      <tbody>
        <tr><td>Average Time</td><td><span id="chart3-avg">—</span></td></tr>
        <tr><td>Average Time (Last 10)</td><td><span id="chart3-avg10">—</span></td></tr>
        <tr><td>Average Time (Last 100)</td><td><span id="chart3-avg100">—</span></td></tr>
        <tr><td>Average Time (Last 1000)</td><td><span id="chart3-avg1000">—</span></td></tr>
        <tr><td>Fastest Run</td><td><span id="chart3-fastest">—</span></td></tr>
        <tr><td>Slowest Run</td><td><span id="chart3-slowest">—</span></td></tr>
        <tr><td>Total Time Spent Running</td><td><span id="chart3-total">—</span></td></tr>
      </tbody>
    </table>
  </div></div><div class="chart-card"><div class="chart-slot" id="chart-4"></div></div><div class="chart-card"><div class="chart-slot" id="chart-5"></div></div><div class="chart-card"><div class="chart-slot" id="chart-6"></div></div><div class="chart-card"><div class="chart-slot" id="chart-7"></div></div><div class="chart-card"><div class="chart-slot" id="chart-8"></div></div><div class="chart-card"><div class="chart-slot" id="chart-9"></div></div><div class="chart-card"><div class="chart-slot" id="chart-10"></div></div><div class="chart-card"><div class="chart-slot" id="chart-11"></div></div><div class="chart-card"><div class="chart-slot" id="chart-12"></div></div><div class="chart-card"><div class="chart-slot" id="chart-13"></div></div><div class="chart-card"><div class="chart-slot" id="chart-14"></div></div><div class="chart-card"><div class="chart-slot" id="chart-15"></div></div></div></div></section>

<script>
(function(){
  const MIN_PX = 6;     // allow very small to ensure full visibility
  const MAX_PX = 24;    // sensible upper bound
  const TITLE_MAX = 28;

  function fitElement(el, maxPx, minPx){
    if(!el) return;
    // Start high, then shrink via binary search
    let low = minPx, high = maxPx, best = minPx;
    // temporarily ensure measurement environment
    el.style.whiteSpace = 'nowrap';
    // binary search for the largest size that fits
    for(let i=0;i<20;i++){
      const mid = (low+high)/2;
      el.style.fontSize = mid + 'px';
      // Force reflow
      const fits = el.scrollWidth <= el.clientWidth + 0.5;
      if(fits){
        best = mid;
        low = mid;
      } else {
        high = mid;
      }
      if (Math.abs(high-low) < 0.25) break;
    }
    el.style.fontSize = best + 'px';
  }

  function fitRunsTable(){
    const root = document.querySelector('#chart-1 .runs-table');
    if(!root) return;
    const tds = root.querySelectorAll('td');
    // Set them briefly to MAX so we measure natural width first
    tds.forEach(td => { td.style.fontSize = MAX_PX + 'px'; });
    // Fit each cell to its column box
    tds.forEach(td => fitElement(td, MAX_PX, MIN_PX));

    // Also fit the title
    const title = document.querySelector('#chart-1 .runs-title');
    if(title){
      title.style.fontSize = TITLE_MAX + 'px';
      fitElement(title, TITLE_MAX, MIN_PX);
    }
  }

  const debounced = (fn, ms=50) => {
    let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(null,args), ms); };
  };

  function installObservers(){
    const container = document.getElementById('chart-1');
    if(!container) return;

    // ResizeObserver for container size changes
    if('ResizeObserver' in window){
      const ro = new ResizeObserver(debounced(fitRunsTable, 50));
      ro.observe(container);
    } else {
      window.addEventListener('resize', debounced(fitRunsTable, 100));
    }

    // MutationObserver to refit when values change
    const mo = new MutationObserver(debounced(fitRunsTable, 20));
    mo.observe(container, { subtree: true, characterData: true, childList: true });

    // Initial fit
    requestAnimationFrame(fitRunsTable);
    window.addEventListener('load', fitRunsTable);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', installObservers);
  } else {
    installObservers();
  }
})();
</script>





<script>
// Reuse existing Google Charts + loadViaJSONP flow, but fetch all cols and read index 92 (Col93)

  // Background store for Col87 (time per run) & Col88 (date EST)
  window.col8788Store = { times: [], dates: [], col94: [], col16: [], col97: null, col97_seconds: null, col97_10: null, col97_10_seconds: null, col97_100: null, col97_100_seconds: null, col97_1000: null, col97_1000_seconds: null, col97_fastest: null, col97_fastest_seconds: null, col97_slowest: null, col97_slowest_seconds: null, col97_total_dhm: null, col97_total_seconds: null, pairs1694: [], loaded: false };

  (function(){
  function startAutoFill(){
    if (typeof chartsReady !== 'undefined' && chartsReady === true && typeof loadViaJSONP === 'function') {
      try {
        loadViaJSONP(GID_PROCESSED, "handleRunsTop5", "select * limit 5");
              // Background load of ALL rows for Col87 (time/run) and Col88 (date EST)
        loadViaJSONP(GID_PROCESSED, "handleCols8788", "select *");
} catch(e) {
        console.error("loadViaJSONP failed:", e);
      }
    } else {
      setTimeout(startAutoFill, 80);
    }
  }

  
window.handleRunsTop5 = function(response){
  try{
    if (!response || response.status !== "ok") {
      console.error("RunsTop5 response not ok:", response);
      const cell = document.getElementById('runs-completed');
      if (cell && !cell.textContent.trim()) cell.textContent = '—';
      if (typeof window.updateStats === 'function') window.updateStats();
      return;
    }
    const dt = new google.visualization.DataTable(response.table);
    const targetCol = 92; // zero-based index => column 93
    const rows = dt.getNumberOfRows();
    const cols = dt.getNumberOfColumns();
    console.log("[AutoFill] rows:", rows, "cols:", cols, "reading col index:", targetCol);

    if (targetCol >= cols) {
      console.error("Target column 93 not found. Columns available:", cols);
      const cell = document.getElementById('runs-completed');
      if (cell && !cell.textContent.trim()) cell.textContent = '—';
      if (typeof window.updateStats === 'function') window.updateStats();
      return;
    }
    const values = [];
    // Emulate existing code pattern: skip first data row if needed
    for (let r = 1; r < Math.min(rows, 5); r++) { // first 5 rows, starting at 1
      const v = dt.getValue(r, targetCol);
      if (v == null) continue;
      const num = typeof v === 'number' ? v : parseInt(String(v).replace(/,/g, ''), 10);
      if (!isNaN(num)) values.push(num);
    }
    const maxVal = values.length ? Math.max.apply(null, values) : null;
    console.log("[AutoFill] Col93 top5 (skipping row 0):", values, "max:", maxVal);
    const cell = document.getElementById('runs-completed');
    if (cell) cell.textContent = (maxVal != null ? maxVal : '—');
    if (typeof window.updateStats === 'function') window.updateStats();
  } catch(e){
    console.error("RunsTop5 handler error:", e);
    const cell = document.getElementById('runs-completed');
    if (cell && !cell.textContent.trim()) cell.textContent = '—';
    if (typeof window.updateStats === 'function') window.updateStats();
  }
};
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startAutoFill);
  } else {
    startAutoFill();
  }
})();
</script>





<script>
(function(){
  function toNumber(text){
    if (text == null) return NaN;
    const n = parseInt(String(text).replace(/,/g,'').trim(), 10);
    return isNaN(n) ? NaN : n;
  }
  function fmt(n){ return n.toLocaleString ? n.toLocaleString() : String(n); }

  window.updateStats = function(){
    const rcEl = document.getElementById('runs-completed');
    const trEl = document.getElementById('total-remaining');
    const pdEl = document.getElementById('percentage-done');
    if (!rcEl) return;
    const rc = toNumber(rcEl.textContent);
    if (!isFinite(rc)) {
      if (trEl) trEl.textContent = '—';
      if (pdEl) pdEl.textContent = '—';
      return;
    }
    const remaining = Math.max(0, 100000 - Math.max(0, Math.min(100000, rc)));
    if (trEl) trEl.textContent = fmt(remaining);
    const pct = (rc / 100000) * 100;
    if (pdEl) pdEl.textContent = pct.toFixed(2) + "%";

    // Trigger resize/autofit if needed
    if (typeof requestAnimationFrame === 'function') {
      requestAnimationFrame(() => {
        if (typeof window !== 'undefined' && window.dispatchEvent) {
          window.dispatchEvent(new Event('resize'));
        }
      });
    }
  };

  // Run once on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => setTimeout(window.updateStats, 50));
  } else {
    setTimeout(window.updateStats, 50);
  }
})();
</script>








<script>
(function(){
  function getInnerWidth(el){
    if (!el) return 0;
    const cs = getComputedStyle(el);
    const pad = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    return Math.max(0, el.clientWidth - pad);
  }

  function maximizeSingleLine(el){
    if (!el) return;
    const container = el.parentElement; // .chart-slot
    const maxWidth = getInnerWidth(container) || container.clientWidth || el.offsetWidth;
    if (!maxWidth) return;

    let lo = 6, hi = 96, best = lo;
    // Warm start: try something big first to avoid too-small look
    el.style.fontSize = hi + "px";
    // Binary search for largest size that fits on one line
    for (let i = 0; i < 20; i++) {
      const mid = (lo + hi) / 2;
      el.style.fontSize = mid + "px";
      const fits = el.scrollWidth <= maxWidth + 0.5; // small fudge
      if (fits) { best = mid; lo = mid; } else { hi = mid; }
      if (Math.abs(hi - lo) < 0.25) break;
    }
    el.style.fontSize = best + "px";
  }

  function fitAllTitles(){
    document.querySelectorAll(".chart-slot h3").forEach(maximizeSingleLine);
  }

  // Keep the title maximized as container resizes or layout changes
  function installObservers(){
    const chart2 = document.getElementById("chart-2");
    if (chart2 && "ResizeObserver" in window) {
      const ro = new ResizeObserver(() => fitAllTitles());
      ro.observe(chart2);
    } else {
      window.addEventListener("resize", fitAllTitles);
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => { fitAllTitles(); installObservers(); });
  } else {
    fitAllTitles(); installObservers();
  }
})();
</script>


<script>
// === BEGIN handleCols8788 (group & average by EST date) ===
window.handleCols8788 = function(response) {
  try {
    if (!response || response.status !== "ok") {
      console.error("[Cols87/88] response not ok:", response);
      return;
    }
    const dt = new google.visualization.DataTable(response.table);
    const rows = dt.getNumberOfRows();
    const cols = dt.getNumberOfColumns();
    const c87 = 86; // zero-based index for column 87 (time per run h:mm:ss)
    const c88 = 87; // zero-based index for column 88 (date played EST)
    const c94 = 93; // zero-based index for column 94
    const c16 = 15; // zero-based index for column 16 (h:mm:ss.mmm)
    if (c87 >= cols || c88 >= cols) {
      console.error("[Cols87/88] Missing expected columns. Available:", cols);
      return;
    }

    const times = [];
    const dates = [];
    const col94 = [];
    const col16 = [];
    const pairs1694 = [];
    for (let r = 1; r < rows; r++) {
      const t = dt.getValue(r, c87);
      const d = dt.getValue(r, c88);
      const v94 = dt.getValue(r, c94);
      const v16 = dt.getValue(r, c16);
      if (t != null) times.push(String(t));
      if (d != null) dates.push(String(d));
      if (v94 != null) col94.push(String(v94));
      if (v16 != null) {
      var str16;
      if (v16 instanceof Date) {
        var hh = v16.getHours();
        var mm = String(v16.getMinutes()).padStart(2, '0');
        var ss = String(v16.getSeconds()).padStart(2, '0');
        str16 = hh + ':' + mm + ':' + ss;
      } else {
        str16 = String(v16);
      }
      col16.push(str16);
      pairs1694.push({ t16: str16, c94: (v94 == null ? null : String(v94)) });
    }
}

    console.log("[Cols87] first 3:", times.slice(0,3));
    console.log("[Cols88] first 3:", dates.slice(0,3));

    if (!window.col8788Store) window.col8788Store = { times: [], dates: [], col94: [], col16: [], col97: null, col97_seconds: null, col97_10: null, col97_10_seconds: null, col97_100: null, col97_100_seconds: null, col97_1000: null, col97_1000_seconds: null, col97_fastest: null, col97_fastest_seconds: null, col97_slowest: null, col97_slowest_seconds: null, col97_total_dhm: null, col97_total_seconds: null, pairs1694: [], loaded: false };
    window.col8788Store.times = times;
    window.col8788Store.dates = dates;
    window.col8788Store.col94 = col94;
        window.col8788Store.col16 = col16;
    window.col8788Store.pairs1694 = pairs1694;
window.col8788Store.loaded = true;

    function parseHMS(str) {
      if (!str) return null;
      const m = String(str).trim().match(/^(\d+):([0-5]?\d):([0-5]?\d)$/);
      if (!m) return null;
      const h = parseInt(m[1], 10);
      const mi = parseInt(m[2], 10);
      const s = parseInt(m[3], 10);
      return h * 3600 + mi * 60 + s;
    }
    function fmtHMS(total) {
      if (total == null || isNaN(total)) return null;
      total = Math.round(total);
      const h = Math.floor(total / 3600);
      const rem = total % 3600;
      const m = Math.floor(rem / 60);
      const s = rem % 60;
      return h + ":" + String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
    }

    const groups = new Map();
    const n = Math.min(times.length, dates.length);
    for (let i = 0; i < n; i++) {
      const secs = parseHMS(times[i]);
      const raw = dates[i];
      if (secs == null || !raw) continue;
      const parts = String(raw).trim().split(/\s+/);
      const displayDate = parts[0] || "";
      const g = groups.get(displayDate);
      if (g) {
        g.sum += secs; g.count += 1;
      } else {
        groups.set(displayDate, { sum: secs, count: 1 });
      }
    }

    const averages = [];
    for (const [displayDate, acc] of groups.entries()) {
      if (acc.count >= 5) { // Only include dates with 5 or more runs
        const avg = acc.sum / acc.count;
        averages.push({ displayDate, avgSeconds: avg, avgHMS: fmtHMS(avg), count: acc.count });
      }
    }

    averages.sort((a, b) => a.avgSeconds - b.avgSeconds);

    

    
    // Expose for Chart 2 renderer
    window.col8788AveragesByDate = averages;
// Now that the array is ready, render into Chart 2 when the DOM is ready
    const runPopulate = () => populateChart2TopN(5);
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', runPopulate, { once:true });
    } else {
      runPopulate();
    }
    console.log("[Cols87 by Date, n>=5, shortest->longest] first 3 averages:", averages.slice(0, 10).map(x => ({ date: x.displayDate, avg: x.avgHMS, n: x.count })));
  } catch (e) {
    console.error("[Cols87/88] handler error:", e);
  }
};

    // Patched Chart 2 population block will be inserted below </script>


<script>
// Fill the first N rows of Chart 2 from window.col8788AveragesByDate
function populateChart2TopN(n = 5){
  try{
    const arr = Array.isArray(window.col8788AveragesByDate) ? window.col8788AveragesByDate : [];
    if (!arr.length) return; // nothing to render yet

    const tbody = document.querySelector('#chart-2 table.runs-table tbody');
    if (!tbody) return;

    // take the first n ranked items and map into the first n rows
    const rows = Array.from(tbody.querySelectorAll('tr')).slice(0, n);
    arr.slice(0, n).forEach((item, idx) => {
      const cells = rows[idx] ? rows[idx].querySelectorAll('td') : null;
      if (!cells || cells.length < 4) return;
      
      // center the # of Runs column without affecting global CSS
      if (cells[1]) { cells[1].style.textAlign = 'center'; cells[1].style.whiteSpace = 'nowrap'; }
cells[0].textContent = String(item.displayDate || '—');  // Date
      cells[1].textContent = String(item.count ?? '—');        // # of Runs
      cells[2].textContent = String(item.avgHMS || '—');       // Average Time
      cells[3].textContent = String(idx + 1);                  // Rank
    });
  } catch(e){
    console.error("[Chart2 Populate] error:", e);
  }
}
</script>


<script>
// Shrink-to-fit utility specifically for Chart 2 cells
(function(){
  function fitText(el, opts){
    if (!el) return;
    const minPx = (opts && opts.minPx) || 10;
    const maxPx = (opts && opts.maxPx) || 16;
    const step  = (opts && opts.step)  || 0.5;
    // Reset to max first so we can shrink down
    el.style.fontSize = maxPx + 'px';
    // If it already fits, done
    if (el.scrollWidth <= el.clientWidth) return;
    // Shrink until it fits or we hit min
    let size = maxPx;
    let guard = 0;
    while (size > minPx && el.scrollWidth > el.clientWidth && guard < 100){
      size -= step;
      el.style.fontSize = size + 'px';
      guard++;
    }
  }

  // Expose for populateChart2TopN to call per-cell
  window.__fitChart2CellText = fitText;

  // Refit on resize for robustness
  const chart2 = document.querySelector('#chart-2 table.runs-table');
  if (chart2 && 'ResizeObserver' in window){
    const ro = new ResizeObserver(() => {
      const rows = chart2.querySelectorAll('tbody tr');
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells[0]) window.__fitChart2CellText(cells[0], {minPx:10, maxPx:16, step:0.5});
        if (cells[1]) window.__fitChart2CellText(cells[1], {minPx:10, maxPx:16, step:0.5});
      });
    });
    ro.observe(chart2);
  } else {
    // Fallback: refit on window resize
    window.addEventListener('resize', () => {
      const rows = document.querySelectorAll('#chart-2 table.runs-table tbody tr');
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells[0]) window.__fitChart2CellText(cells[0], {minPx:10, maxPx:16, step:0.5});
        if (cells[1]) window.__fitChart2CellText(cells[1], {minPx:10, maxPx:16, step:0.5});
      });
    });
  }
})();
</script>

</body>
</html>

<script>
(function(){
  function logOnce(){
    try{
      if (window.col8788Store && Array.isArray(window.col8788Store.col94) && window.col8788Store.col94.length){
        console.log("First 100 items from Col94:", window.col8788Store.col94.slice(0, 100));
        return true;
      }
    }catch(e){}
    return false;
  }
  if (!logOnce()){
    var iv = setInterval(function(){
      if (logOnce()) clearInterval(iv);
    }, 200);
    setTimeout(function(){ clearInterval(iv); }, 15000);
  }
})();
</script>


<script>
(function(){
  
function toSecondsFromCol16(val){
  if (val == null) return null;
  // Date object from Google DataTable (e.g., Sat Dec 30 1899 00:25:54 ...)
  if (val instanceof Date){
    return val.getHours()*3600 + val.getMinutes()*60 + val.getSeconds() + (val.getMilliseconds()||0)/1000;
  }
  // Numeric fraction-of-day (Excel/Sheets style): 1 day == 86400 seconds
  if (typeof val === 'number' && isFinite(val)){
    return val * 86400;
  }
  // String formats: h:mm:ss.mmm or h:mm:ss
  var s = String(val).trim();
  var m = s.match(/^(\d+):([0-5]?\d):([0-5]?\d)(?:\.(\d{1,3}))?$/);
  if (m){
    var h = parseInt(m[1],10), mi = parseInt(m[2],10), se = parseInt(m[3],10);
    var ms = m[4] != null ? parseInt((m[4] + '000').slice(0,3),10) : 0;
    return h*3600 + mi*60 + se + ms/1000;
  }
  m = s.match(/^(\d+):([0-5]?\d):([0-5]?\d)$/);
  if (m){
    var h2 = parseInt(m[1],10), mi2 = parseInt(m[2],10), se2 = parseInt(m[3],10);
    return h2*3600 + mi2*60 + se2;
  }
  return null;
}
  function fmtHMS(secs){
    if (secs == null || !isFinite(secs)) return null;
    secs = Math.round(secs);
    var h = Math.floor(secs / 3600);
    var rem = secs % 3600;
    var m = Math.floor(rem / 60);
    var s = rem % 60;
    return h + ":" + String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
  }
  function toDHM(total){
    if (!isFinite(total)) return null;
    total = Math.floor(total);
    var days = Math.floor(total / 86400);
    var remD = total % 86400;
    var hours = Math.floor(remD / 3600);
    var remH = remD % 3600;
    var mins = Math.floor(remH / 60);
    return { days: days, hours: hours, mins: mins };
  }
  function compute(){
    try{
      var store = window.col8788Store || {};
      if (!store.loaded || !Array.isArray(store.col16) || !Array.isArray(store.col94)) return false;
      var pairs = (Array.isArray(store.pairs1694) && store.pairs1694.length) ? store.pairs1694
                 : store.col16.map(function(t16, idx){ return { t16: String(t16), c94: (store.col94[idx] != null ? String(store.col94[idx]) : null) };
});
      console.log("[Chart-3] First 10 Col16 values:", (window.col8788Store && window.col8788Store.col16) ? window.col8788Store.col16.slice(0,10) : []);
      var keep = pairs.filter(function(p){
        return !(String(p.c94 || "").trim().toLowerCase() === "true");
      });
      function avgSeconds(arr){
        var sum = 0, count = 0;
        for (var i=0;i<arr.length;i++){
          var secs = toSecondsFromCol16(arr[i].t16);
          if (typeof secs === "number" && isFinite(secs)){ sum += secs; count++; }
        }
        return count ? (sum / count) : null;
      }
      var avgAll = avgSeconds(keep);
      var avg10 = avgSeconds(keep.slice(0,10));
      var avg100 = avgSeconds(keep.slice(0,100));
      var avg1000 = avgSeconds(keep.slice(0,1000));
      var secsArr = keep.map(function(p){ return toSecondsFromCol16(p.t16); }).filter(function(v){ return typeof v === "number" && isFinite(v); });
      var fastest = secsArr.length ? Math.min.apply(null, secsArr) : null;
      var slowest = secsArr.length ? Math.max.apply(null, secsArr) : null;
      var totalSecs = secsArr.reduce(function(a,b){ return a+b; }, 0);
      var dhm = toDHM(totalSecs);
      var dhmStr = dhm ? (dhm.days + " days, " + dhm.hours + " hours, " + dhm.mins + " minutes") : null;

      // Save
      store.col97_seconds = avgAll; store.col97 = fmtHMS(avgAll);
      store.col97_10_seconds = avg10; store.col97_10 = fmtHMS(avg10);
      store.col97_100_seconds = avg100; store.col97_100 = fmtHMS(avg100);
      store.col97_1000_seconds = avg1000; store.col97_1000 = fmtHMS(avg1000);
      store.col97_fastest_seconds = fastest; store.col97_fastest = fmtHMS(fastest);
      store.col97_slowest_seconds = slowest; store.col97_slowest = fmtHMS(slowest);
      store.col97_total_seconds = totalSecs; store.col97_total_dhm = dhmStr;

      // Console
      console.log("[Chart-3] Average (all, Col16 after filtering):", store.col97, "(n=", keep.length, ")");
      console.log("[Chart-3] Average (first 10):", store.col97_10, "(n=", Math.min(10, keep.length), ")");
      console.log("[Chart-3] Average (first 100):", store.col97_100, "(n=", Math.min(100, keep.length), ")");
      console.log("[Chart-3] Average (first 1000):", store.col97_1000, "(n=", Math.min(1000, keep.length), ")");
      console.log("[Chart-3] Fastest run:", store.col97_fastest);
      console.log("[Chart-3] Slowest run:", store.col97_slowest);
      console.log("[Chart-3] Total time (D/H/M):", store.col97_total_dhm);

      // Wire DOM
      function setText(id, val){ var el = document.getElementById(id); if (el) el.textContent = (val != null ? val : '—'); }
      setText('chart3-avg', store.col97);
      setText('chart3-avg10', store.col97_10);
      setText('chart3-avg100', store.col97_100);
      setText('chart3-avg1000', store.col97_1000);
      setText('chart3-fastest', store.col97_fastest);
      setText('chart3-slowest', store.col97_slowest);
      setText('chart3-total', store.col97_total_dhm);
      return true;
    }catch(e){
      console.error("[Chart-3 compute] error:", e);
      return true; // stop retrying if code error to avoid spam
    }
  }
  if (!compute()){
    var iv = setInterval(function(){ if (compute()) clearInterval(iv); }, 200);
    setTimeout(function(){ clearInterval(iv); }, 15000);
  }
})();
</script>
